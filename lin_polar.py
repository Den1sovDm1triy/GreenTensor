# -*- coding: utf-8 -*-
"""lin polar.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/171QVLCrADtlxr-WnyrE0nftBVXKMDlfi

# Дифракция на линзе Люнеберга
при облучении источником поля линейной поляризации в дальней зоне
"""

import math
import cmath

#Задаем радиус Линзы
k0 = 15 * (math.pi)
print ('Радиус сферы k0 =', k0)

#Точность расчетов берется в два раза больше чем значение k0
#Функция ceil() определяет, какая из границ интервала наибольшая и записывает её в результат округления.
toch = math.ceil(k0*2)
print ('Точность расчетов toch =', toch)

#Параметры материала Линзы
#Для этого примера не допускаются параметры с реактивной (внимной) частью параметров следы eps / miy
#так как из формулы расчета etta был исключен первый множитель (экспонента)
#возникала ошибка can't convert complex to float (нужно решить чуть позднее)
#a - нормированные радиусы слоев
#a = [0.53, 0.75, 0.93, 1]
a = [0.34, 0.49, 0.59, 0.69, 0.77, 0.84, 0.91, 0.97]
#eps - диэлектрическая проницаемость материала
#eps = [1.86, 1.57, 1.28, 1]
miy = [1.94, 1.82, 1.71, 1.59, 1.47, 1.35, 1.24, 1.12]
#miy - магнитная проницаемость материала
eps = [1, 1, 1, 1, 1, 1, 1, 1]
print ('\n a =', a, '\n eps =', eps,'\n miy =', miy)

#Расчет коэффициентов k, которые связывают слои
#Например для 4-х слойной линзы это: k0a1, k1a1, k2a1, k2a2, k3a2, k3a3, k4a3, k4a4

#Создаем массив для переменных среды
print('Создание массивов')
n = len(eps)

alfa = [0 * n for i in range(n)]
print('alfa:', alfa)

beta = [0 * n for i in range(n)]
print ('beta:', beta)

etta = [0 * n for i in range(n)]
print ('etta:', etta)

k= [[0] * n for i in range(n)]
print('k:', k)

print('###-###-###')

#Расчет переменных, входящих в коэффициенты k
print('Расчет переменных, входящих в коэффициенты k')

for i in range(len(eps)):
  alfa[i] = math.atan((eps[i]).imag / (eps[i]).real)
  print ('alfa:', alfa)

  beta[i] = math.atan((miy[i]).imag / (miy[i]).real)
  print ('beta:', beta)

  etta[i] = math.sqrt(math.fabs(eps[i]) * math.fabs(miy[i]))
  print ('etta:', etta)

print('###-###-###')

#Расчет коэффициентов k
print('Расчет переменных, входящих в коэффициенты k')

j = 0; #Индекс для рассчета коэффициентов k
for i in range (n):
  k[i][j] = k0 * a[i] * etta[j]
  if j < n - 1:
    j = j + 1
    k[i][j] = k0 * a[i] * etta[j]
print ('k:', k)

print('###-###-###')

#Функции Бесселя
import scipy.special

#scipy.special.jv(v, z, out=None)
#https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jv.html#scipy.special.jv
#Bessel function of the first kind of real order and complex argument.
#Функция Бесселя первого рода д]
J = [0 * n for i in range(toch)]

for i in range(toch):
  nu = i + 1
  J[i] = (scipy.special.jv(nu + 0.5, k[0][0])) * (math.sqrt(k[0][0] * math.pi/2))

print('J:', J)

#scipy.special.ivp
#Compute derivatives of modified Bessel functions of the first kind.
#Вычислить производные модифицированных функций Бесселя первого рода.
Jpr = [0 * n for i in range(toch)]

for i in range(toch):
  nu = i + 1
  Jpr[i] = ((nu / (2 * nu + 1)) *  (scipy.special.jv(nu - 0.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) -
      ((nu + 1) / (2 * nu + 1)) *  (scipy.special.jv(nu + 1.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) +
      (J[i] / k[0][0]))

print('Jpr:', Jpr)

#scipy.special.yv(v, z, out=None)
#Bessel function of the second kind of real order and complex argument.
#Функция Бесселя второго рода (Функция Неймана) действительного порядка и комплексного аргумента.
N = [0 * n for i in range(toch)]

for i in range(toch):
  N[i] = scipy.special.yv((i+1) + 0.5, k[0][0]) * math.sqrt(k[0][0]* math.pi/2)
print('N:', N)

Npr = [0 * n for i in range(toch)]
for i in range(toch):
  nu = i + 1
  Npr[i] = ((nu / (2 * nu + 1)) *  (scipy.special.yv(nu - 0.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) -
      ((nu + 1) / (2 * nu + 1)) *  (scipy.special.yv(nu + 1.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) +
      (N[i] / k[0][0]))
print('Npr:', Npr)

C = [[0] * (len(etta)-1) for i in range(toch)]
for i in range(toch-1):
  for j in range(len(etta)-1):
    nu = i+1
    #C = J*Npr-N*Jpr
    C[i][j]=((scipy.special.jv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))*(((nu/(2*nu+1))*(((scipy.special.yv(nu-0.5,k[j][j+1]))*
     (math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1]-(((nu+1)/(2*nu+1))*((scipy.special.yv(nu+1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/
     k[j][j+1])* k[j][j+1]+((scipy.special.yv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])-((scipy.special.yv(nu+0.5,k[j+1][j+1]))*
     (math.sqrt(k[j+1][j+1]*math.pi/2)))*(((nu/(2*nu+1))*(((scipy.special.jv(nu-0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1]-
     (((nu+1)/(2*nu+1))*((scipy.special.jv(nu+1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])*k[j][j+1]+((scipy.special.jv(nu+0.5,k[j][j+1]))*
     (math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])

print('C:', C)

Cpr = [[0] * (len(etta)-1) for i in range(toch)]
for i in range(toch):
  for j in range(len(etta)-1):
    nu = i+1
    #Cpr(n)=Jpr*Npr-Npr*Jpr
    Cpr[i][j] =(((( nu / (2 * nu + 1)) * (((scipy.special.jv(nu - 0.5, k[j+1][j+1])) * (math.sqrt(k[j+1][j+1] * math.pi/2))) / k[j+1][j+1])) *
               k[j+1][j+1]-(((nu +1)/(2*nu +1))*((scipy.special.jv(nu +1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2))) /
               k[j+1][j+1])*k[j+1][j+1]+((scipy.special.jv(nu +0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
               (((nu /(2*nu +1))*(((scipy.special.yv(nu -0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1] -
               (((nu +1)/(2*nu +1))*((scipy.special.yv(nu +1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])*k[j][j+1] +
               ((scipy.special.yv(nu +0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])) -((((nu /(2*nu +1)) *
               (((scipy.special.yv(nu -0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]))*k[j+1][j+1]-(((nu +1)/(2*nu +1)) *
               ((scipy.special.yv(nu +1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1])*k[j+1][j+1] +
               ((scipy.special.yv(nu +0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1])*(((nu /(2*nu +1)) *
               (((scipy.special.jv(nu -0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1]-(((nu +1)/(2*nu +1)) *
               ((scipy.special.jv(nu +1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])*k[j][j+1] +
               ((scipy.special.jv(nu +0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))
print('Cpr:', Cpr)

S = [[0] * (len(etta)-1) for i in range(toch)]
for i in range(toch):
  for j in range(len(etta)-1):
    nu = i+1
    S[i][j]=(((scipy.special.yv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))*((scipy.special.jv(nu+0.5,k[j][j+1])) *
            (math.sqrt(k[j][j+1]*math.pi/2))))-(((scipy.special.jv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2))) *
            ((scipy.special.yv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2))))
print('S:', S)

Spr = [[0] * (len(etta)-1) for i in range(toch)]
for i in range(toch):
  for j in range(len(etta)-1):
    nu = i+1
    Spr[i][j]=((((nu/(2*nu+1))*(((scipy.special.yv(nu-0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1])) *
              k[j+1][j+1] -(((nu+1)/(2*nu+1))*(( scipy.special.yv(nu+1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2))) /
              k[j+1][j+1])*k[j+1][j+1] +((scipy.special.yv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
              ((scipy.special.jv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))) -((((nu/(2*nu+1)) *
              ((( scipy.special.jv(nu-0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]))*k[j+1][j+1] -
              (((nu+1)/(2*nu+1))*((scipy.special.jv(nu+1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
              k[j+1][j+1] +((scipy.special.jv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
              ((scipy.special.yv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2))))
print('Spr:', Spr)

alfa.append(0)
eps.append(len(eps))
print('alfa:', alfa)
print('alfa[', len(alfa)-1,']:', alfa[len(alfa)-1])
print('eps[', len(eps)-1,']:', eps[len(eps)-1])
Z = [[0] * (len(a)) for i in range(toch)]
Y = [[0] * (len(a)) for i in range(toch)]
for i in range(toch):
  for h in range(len(a)):

    if h==0:
     Z[i][h] = (cmath.sqrt((cmath.exp(alfa[1]*1j)*abs(eps[1]))/((cmath.exp(alfa[0]*1j)*abs(eps[0])))))*((Jpr[i])/(J[i]))
     Y[i][h] = (cmath.sqrt((cmath.exp(alfa[0]*1j)*abs(eps[0]))/((cmath.exp(alfa[1]*1j)*abs(eps[1])))))*((Jpr[i])/(J[i]))


#### Этот блок надо починить. Не правильно считает для h=3, тут костыль ###############
    else:
      if h==3:
       Z[i][h]=(cmath.sqrt((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1]))/((cmath.exp(alfa[h]*1j)*abs(eps[h]))))) *(Cpr[i][h-1]+Z[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Z[i][h-1]*S[i][h-1])/2
       Y[i][h]=(cmath.sqrt((cmath.exp(alfa[h]*1j)*abs(eps[h]))/((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1])))))*(Cpr[i][h-1]+Y[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Y[i][h-1]*S[i][h-1])*2

######################################################################################

      else:
         Z[i][h]=(cmath.sqrt((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1]))/((cmath.exp(alfa[h]*1j)*abs(eps[h]))))) *(Cpr[i][h-1]+Z[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Z[i][h-1]*S[i][h-1])
         Y[i][h]=(cmath.sqrt((cmath.exp(alfa[h]*1j)*abs(eps[h]))/((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1])))))*(Cpr[i][h-1]+Y[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Y[i][h-1]*S[i][h-1])

print('Z:', Z)
print('Y:', Y)

mJ = [0 * n for i in range(toch)]
mJpr = [0 * n for i in range(toch)]
mH = [0 * n for i in range(toch)]
mHpr = [0 * n for i in range(toch)]

for i in range(toch):
  nu=i+1

  mJ[i] = (scipy.special.jv(nu+0.5,k0))*(math.sqrt(k0*math.pi/2))

  mJpr[i] = ((nu/(2*nu+1))*(((scipy.special.jv(nu-0.5,k0))*(math.sqrt(k0*math.pi/2)))/k0))*k0-(((nu+1)/(2*nu+1))*((scipy.special.jv(nu+1.5,k0))*(math.sqrt(k0*math.pi/2)))/k0)*k0+((scipy.special.jv(nu+0.5,k0))*(math.sqrt(k0*math.pi/2)))/k0;

  mH[i] = (scipy.special.hankel1(nu+0.5,k0))*(math.sqrt(k0*math.pi/2))

  mHpr[i] = ((nu/(2*nu+1))*(((scipy.special.hankel1(nu-0.5,k0))*(cmath.sqrt(k0*math.pi/2)))/k0))*k0 -(((nu+1)/(2*nu+1))*((scipy.special.hankel1(nu+1.5,k0))*(cmath.sqrt(k0*math.pi/2)))/k0)*k0+((scipy.special.hankel1(nu+0.5,k0))*(cmath.sqrt(k0*math.pi/2)))/k0

print('mJ:', mJ)
print('mJpr:', mJpr)
print('mH:', mH)
print('mHpr:', mHpr)

Mn = [0 * n for i in range(toch)]
Nn = [0 * n for i in range(toch)]

for i in range(toch):
  nu=i+1
  Mn[i]=(Z[i][h]*mJ[i]-mJpr[i])/(Z[i][h]*mH[i]-mHpr[i])
  Mn[i]=Mn[i].real-Mn[i].imag*1j
  Nn[i]=(Y[i][h]*mJ[i]-mJpr[i])/(Y[i][h]*mH[i]-mHpr[i])
  Nn[i]=Nn[i].real-Nn[i].imag*1j

print('Mn:', Mn)
print('Nn:', Nn)

#teta=0.01:pi/180:2*pi; %диапазон изменения углов для декартовой системы координат

i = [1, 2, 3]
teta_start = 0.01
teta_stop = 360
teta_diap = abs(teta_stop)-abs(teta_start)
step = math.pi/360
steps = int(((teta_diap)*(math.pi/180)) / step)
teta = [0 * n for i in range(steps)]
cos_teta = [0 * n for i in range(steps)]
print(step, steps, math.pi)
for i in range(steps):
  if i == 0:
    teta[i] = (teta_start)*(math.pi/180)
  else:
    teta[i] = teta[i-1] + step
print(teta)

for i in range(steps):
  cos_teta[i] = math.cos(teta[i])
print(cos_teta)

M = [0 * n for i in range(steps)]
Lm0=[0 * n for i in range(steps)]
Lm1=[0 * n for i in range(steps)]
Lm2=[0 * n for i in range(steps)]
pii = [[0] * ((2*steps+1)) for i in range(toch+1)]
tay = [[0] * ((2*steps+1)) for i in range(toch+1)]
m=0

for i in range(toch):
  m = m+1
  M = scipy.special.lpmv(0, m, cos_teta)
  Lm0 = M
  M = scipy.special.lpmv(1, m, cos_teta)
  Lm1 = M

  if m<2:
   Lm2 = 0
  else:
   M = scipy.special.lpmv(2, m, cos_teta)
   Lm2 = M

  for z in range(len(teta)):
    if (teta[z] > 0) & (teta[z] < math.pi):
      pii[i][z] = ((1)*Lm1[z])/(math.sin(teta[z]))
    else:
      if (teta[z] > math.pi) & (teta[z] < 2*math.pi):
       pii[i][z] = ((-1)*Lm1[z])/(math.sin(teta[z]))

  for z in range(len(teta)):
    if m<2:
      tay[i][z] = (1/2)*(-m*(m+1)*Lm0[z])
    else:
      tay[i][z] = (1/2)*(Lm2[z]-m*(m+1)*Lm0[z])

E_teta= [[0] * (len(teta)) for i in range(toch)]
P_teta= [[0] * (len(teta)) for i in range(toch)]
y=0

for z in range(len(teta)):
  for p in range(toch):
    y=p+1
    E_teta[p][z]=((((2*y+1)/(y*(y+1)))*((-1)**y))*(tay[p][z]*Mn[p]-pii[p][z]*Nn[p]))

  for p in range(toch):
    y=p+1
    P_teta[0][z]=(P_teta[0][z]+E_teta[p][z])
  for p in range(toch):
    P_teta[0][z]=abs(P_teta[0][z])


print('P_teta:', P_teta)
print('E_teta:', E_teta)

tetay = [0 * n for i in range(steps)]
DN_NORM = [0 * n for i in range(len(teta))]

P_teta_max = 0

for i in range(len(teta)):
  if P_teta[0][i] > P_teta_max:
    P_teta_max = P_teta[0][i]
print(P_teta_max)

for i in range(len(teta)):
  tetay[i] = teta[i]*(steps/math.pi)

tetay.reverse()
print(tetay)

for i in range(len(teta)):
  DN_NORM[i] = 20*math.log10(P_teta[0][i]/P_teta_max)

print(DN_NORM)

import matplotlib.pyplot as plt

plt.plot(tetay,DN_NORM,'-k','LineWidth',0, scalex='true')
plt.show()

"""# Функция scipy.special.**lpmn**

Из Матлаба:
M=legendre(i,cos(teta));
При i=1 возвращает в Lm0 значиния для поленома лежандра нулевого порядка m=0
(т.е. вся первая строка = полиномы нулевого порядка)

M(1,:)
ans =

  Columns 1 through 13

    0.9373    0.5742    0.0730   -0.3065   -0.3952   -0.2061    0.0898    0.2830    0.2588    0.0591   -0.1619   -0.2505   -0.1568
  
  Для значения
cos(teta)

ans =

  Columns 1 through 13

    1.0000    0.9996    0.9990    0.9981    0.9968    0.9953    0.9934    0.9913    0.9888    0.9861    0.9830    0.9797    0.9760
Скрин из матлаба:
![Screenshot 2023-08-05 174415.png](data:image/png;base64,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)
"""

import scipy.special
scipy.special.lpmn(1, 1, 0.9996)

import scipy.special
scipy.special.lpmn(1, 2, 0.9996)

"""# Функция scipy.special.**lpmv**"""

import scipy.special
# 1 - первое значение, это порядок
# 2 - второе значение, это степень
# 0.9996 - значение угла
# сходится с функцией из матлаба M=legendre(2,0.9996), значение -0.0848103903054842 будет во второй строке,
#т.к. вторая строка - это первый прядок. Первая строка - это нулевой порядок
scipy.special.lpmv(1, 2, 0.9996, out=None)

"""![Screenshot 2023-08-05 180540.png](data:image/png;base64,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)

# Результат с графиками в одном файле
"""

import math
import cmath
#Функции Бесселя
import scipy.special
import matplotlib.pyplot as plt
import numpy as np

#Задаем радиус Линзы
k0 = 15 * (math.pi)
toch = math.ceil(k0*2)

a = [0.34, 0.49, 0.59, 0.69, 0.77, 0.84, 0.91, 0.97]
miy = [1.94, 1.82, 1.71, 1.59, 1.47, 1.35, 1.24, 1.12]
eps = [1, 1, 1, 1, 1, 1, 1, 1]

#Создаем массив для переменных среды
n = len(eps)

alfa = [0 * n for i in range(n)]
beta = [0 * n for i in range(n)]
etta = [0 * n for i in range(n)]

k= [[0] * n for i in range(n)]

#Расчет переменных, входящих в коэффициенты k
for i in range(len(eps)):
  alfa[i] = math.atan((eps[i]).imag / (eps[i]).real)
  beta[i] = math.atan((miy[i]).imag / (miy[i]).real)
  etta[i] = math.sqrt(math.fabs(eps[i]) * math.fabs(miy[i]))

#Расчет коэффициентов k
j = 0; #Индекс для рассчета коэффициентов k
for i in range (n):
  k[i][j] = k0 * a[i] * etta[j]
  if j < n - 1:
    j = j + 1
    k[i][j] = k0 * a[i] * etta[j]

#scipy.special.jv(v, z, out=None)
#Bessel function of the first kind of real order and complex argument.
#Функция Бесселя первого рода д]
J = [0 * n for i in range(toch)]

for i in range(toch):
  nu = i + 1
  J[i] = (scipy.special.jv(nu + 0.5, k[0][0])) * (math.sqrt(k[0][0] * math.pi/2))

#scipy.special.ivp
#Compute derivatives of modified Bessel functions of the first kind.
#Вычислить производные модифицированных функций Бесселя первого рода.
Jpr = [0 * n for i in range(toch)]

for i in range(toch):
  nu = i + 1
  Jpr[i] = ((nu / (2 * nu + 1)) *  (scipy.special.jv(nu - 0.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) -
      ((nu + 1) / (2 * nu + 1)) *  (scipy.special.jv(nu + 1.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) +
      (J[i] / k[0][0]))

#scipy.special.yv(v, z, out=None)
#Bessel function of the second kind of real order and complex argument.
#Функция Бесселя второго рода (Функция Неймана) действительного порядка и комплексного аргумента.
N = [0 * n for i in range(toch)]

for i in range(toch):
  N[i] = scipy.special.yv((i+1) + 0.5, k[0][0]) * math.sqrt(k[0][0]* math.pi/2)

Npr = [0 * n for i in range(toch)]
for i in range(toch):
  nu = i + 1
  Npr[i] = ((nu / (2 * nu + 1)) *  (scipy.special.yv(nu - 0.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) -
      ((nu + 1) / (2 * nu + 1)) *  (scipy.special.yv(nu + 1.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) +
      (N[i] / k[0][0]))

C = [[0] * (len(etta)-1) for i in range(toch)]
for i in range(toch-1):
  for j in range(len(etta)-1):
    nu = i+1
    #C = J*Npr-N*Jpr
    C[i][j]=((scipy.special.jv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))*(((nu/(2*nu+1))*(((scipy.special.yv(nu-0.5,k[j][j+1]))*
     (math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1]-(((nu+1)/(2*nu+1))*((scipy.special.yv(nu+1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/
     k[j][j+1])* k[j][j+1]+((scipy.special.yv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])-((scipy.special.yv(nu+0.5,k[j+1][j+1]))*
     (math.sqrt(k[j+1][j+1]*math.pi/2)))*(((nu/(2*nu+1))*(((scipy.special.jv(nu-0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1]-
     (((nu+1)/(2*nu+1))*((scipy.special.jv(nu+1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])*k[j][j+1]+((scipy.special.jv(nu+0.5,k[j][j+1]))*
     (math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])

#Производная C
Cpr = [[0] * (len(etta)-1) for i in range(toch)]
for i in range(toch):
  for j in range(len(etta)-1):
    nu = i+1
    #Cpr(n)=Jpr*Npr-Npr*Jpr
    Cpr[i][j] =(((( nu / (2 * nu + 1)) * (((scipy.special.jv(nu - 0.5, k[j+1][j+1])) * (math.sqrt(k[j+1][j+1] * math.pi/2))) / k[j+1][j+1])) *
               k[j+1][j+1]-(((nu +1)/(2*nu +1))*((scipy.special.jv(nu +1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2))) /
               k[j+1][j+1])*k[j+1][j+1]+((scipy.special.jv(nu +0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
               (((nu /(2*nu +1))*(((scipy.special.yv(nu -0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1] -
               (((nu +1)/(2*nu +1))*((scipy.special.yv(nu +1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])*k[j][j+1] +
               ((scipy.special.yv(nu +0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])) -((((nu /(2*nu +1)) *
               (((scipy.special.yv(nu -0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]))*k[j+1][j+1]-(((nu +1)/(2*nu +1)) *
               ((scipy.special.yv(nu +1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1])*k[j+1][j+1] +
               ((scipy.special.yv(nu +0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1])*(((nu /(2*nu +1)) *
               (((scipy.special.jv(nu -0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1]-(((nu +1)/(2*nu +1)) *
               ((scipy.special.jv(nu +1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])*k[j][j+1] +
               ((scipy.special.jv(nu +0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))

S = [[0] * (len(etta)-1) for i in range(toch)]
for i in range(toch):
  for j in range(len(etta)-1):
    nu = i+1
    S[i][j]=(((scipy.special.yv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))*((scipy.special.jv(nu+0.5,k[j][j+1])) *
            (math.sqrt(k[j][j+1]*math.pi/2))))-(((scipy.special.jv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2))) *
            ((scipy.special.yv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2))))

#Производная S
Spr = [[0] * (len(etta)-1) for i in range(toch)]
for i in range(toch):
  for j in range(len(etta)-1):
    nu = i+1
    Spr[i][j]=((((nu/(2*nu+1))*(((scipy.special.yv(nu-0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1])) *
              k[j+1][j+1] -(((nu+1)/(2*nu+1))*(( scipy.special.yv(nu+1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2))) /
              k[j+1][j+1])*k[j+1][j+1] +((scipy.special.yv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
              ((scipy.special.jv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))) -((((nu/(2*nu+1)) *
              ((( scipy.special.jv(nu-0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]))*k[j+1][j+1] -
              (((nu+1)/(2*nu+1))*((scipy.special.jv(nu+1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
              k[j+1][j+1] +((scipy.special.jv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
              ((scipy.special.yv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2))))

alfa.append(0)
eps.append(len(eps))
Z = [[0] * (len(a)) for i in range(toch)]
Y = [[0] * (len(a)) for i in range(toch)]
for i in range(toch):
  for h in range(len(a)):

    if h==0:
     Z[i][h] = (cmath.sqrt((cmath.exp(alfa[1]*1j)*abs(eps[1]))/((cmath.exp(alfa[0]*1j)*abs(eps[0])))))*((Jpr[i])/(J[i]))
     Y[i][h] = (cmath.sqrt((cmath.exp(alfa[0]*1j)*abs(eps[0]))/((cmath.exp(alfa[1]*1j)*abs(eps[1])))))*((Jpr[i])/(J[i]))


#### Этот блок надо починить. Не правильно считает для h=3, тут костыль ###############
    else:
      if h==3:
       Z[i][h]=(cmath.sqrt((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1]))/((cmath.exp(alfa[h]*1j)*abs(eps[h]))))) *(Cpr[i][h-1]+Z[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Z[i][h-1]*S[i][h-1])/2
       Y[i][h]=(cmath.sqrt((cmath.exp(alfa[h]*1j)*abs(eps[h]))/((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1])))))*(Cpr[i][h-1]+Y[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Y[i][h-1]*S[i][h-1])*2

######################################################################################

      else:
         Z[i][h]=(cmath.sqrt((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1]))/((cmath.exp(alfa[h]*1j)*abs(eps[h]))))) *(Cpr[i][h-1]+Z[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Z[i][h-1]*S[i][h-1])
         Y[i][h]=(cmath.sqrt((cmath.exp(alfa[h]*1j)*abs(eps[h]))/((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1])))))*(Cpr[i][h-1]+Y[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Y[i][h-1]*S[i][h-1])

######################################################################################
mJ = [0 * n for i in range(toch)]
mJpr = [0 * n for i in range(toch)]
mH = [0 * n for i in range(toch)]
mHpr = [0 * n for i in range(toch)]

for i in range(toch):
  nu=i+1

  mJ[i] = (scipy.special.jv(nu+0.5,k0))*(math.sqrt(k0*math.pi/2))

  mJpr[i] = ((nu/(2*nu+1))*(((scipy.special.jv(nu-0.5,k0))*(math.sqrt(k0*math.pi/2)))/k0))*k0-(((nu+1)/(2*nu+1))*((scipy.special.jv(nu+1.5,k0))*(math.sqrt(k0*math.pi/2)))/k0)*k0+((scipy.special.jv(nu+0.5,k0))*(math.sqrt(k0*math.pi/2)))/k0;

  mH[i] = (scipy.special.hankel1(nu+0.5,k0))*(math.sqrt(k0*math.pi/2))

  mHpr[i] = ((nu/(2*nu+1))*(((scipy.special.hankel1(nu-0.5,k0))*(cmath.sqrt(k0*math.pi/2)))/k0))*k0 -(((nu+1)/(2*nu+1))*((scipy.special.hankel1(nu+1.5,k0))*(cmath.sqrt(k0*math.pi/2)))/k0)*k0+((scipy.special.hankel1(nu+0.5,k0))*(cmath.sqrt(k0*math.pi/2)))/k0

######################################################################################
Mn = [0 * n for i in range(toch)]
Nn = [0 * n for i in range(toch)]

for i in range(toch):
  nu=i+1
  Mn[i]=(Z[i][h]*mJ[i]-mJpr[i])/(Z[i][h]*mH[i]-mHpr[i])
  Mn[i]=Mn[i].real-Mn[i].imag*1j
  Nn[i]=(Y[i][h]*mJ[i]-mJpr[i])/(Y[i][h]*mH[i]-mHpr[i])
  Nn[i]=Nn[i].real-Nn[i].imag*1j

#teta=0.01:pi/180:2*pi; %диапазон изменения углов для декартовой системы координат

i = [1, 2, 3]
teta_start = 0.01
teta_stop = 360
teta_diap = abs(teta_stop)-abs(teta_start)
step = math.pi/360
steps = int(((teta_diap)*(math.pi/180)) / step)
teta = [0 * n for i in range(steps)]
cos_teta = [0 * n for i in range(steps)]
print(step, steps, math.pi)
for i in range(steps):
  if i == 0:
    teta[i] = (teta_start)*(math.pi/180)
  else:
    teta[i] = teta[i-1] + step
print(teta)

for i in range(steps):
  cos_teta[i] = math.cos(teta[i])

M = [0 * n for i in range(steps)]
Lm0=[0 * n for i in range(steps)]
Lm1=[0 * n for i in range(steps)]
Lm2=[0 * n for i in range(steps)]
pii = [[0] * ((2*steps+1)) for i in range(toch+1)]
tay = [[0] * ((2*steps+1)) for i in range(toch+1)]
m=0

for i in range(toch):
  m = m+1
  M = scipy.special.lpmv(0, m, cos_teta)
  Lm0 = M
  M = scipy.special.lpmv(1, m, cos_teta)
  Lm1 = M

  if m<2:
   Lm2 = 0
  else:
   M = scipy.special.lpmv(2, m, cos_teta)
   Lm2 = M

  for z in range(len(teta)):
    if (teta[z] > 0) & (teta[z] < math.pi):
      pii[i][z] = ((1)*Lm1[z])/(math.sin(teta[z]))
    else:
      if (teta[z] > math.pi) & (teta[z] < 2*math.pi):
       pii[i][z] = ((-1)*Lm1[z])/(math.sin(teta[z]))

  for z in range(len(teta)):
    if m<2:
      tay[i][z] = (1/2)*(-m*(m+1)*Lm0[z])
    else:
      tay[i][z] = (1/2)*(Lm2[z]-m*(m+1)*Lm0[z])

######################################################################################

E_teta= [[0] * (len(teta)) for i in range(toch)]
P_teta= [[0] * (len(teta)) for i in range(toch)]
y=0

for z in range(len(teta)):
  for p in range(toch):
    y=p+1
    E_teta[p][z]=((((2*y+1)/(y*(y+1)))*((-1)**y))*(tay[p][z]*Mn[p]-pii[p][z]*Nn[p]))

  for p in range(toch):
    y=p+1
    P_teta[0][z]=(P_teta[0][z]+E_teta[p][z])
  for p in range(toch):
    P_teta[0][z]=abs(P_teta[0][z])

######################################################################################

tetay = [0 * n for i in range(steps)]
DN_NORM = [0 * n for i in range(len(teta))]

P_teta_max = 0

for i in range(len(teta)):
  if P_teta[0][i] > P_teta_max:
    P_teta_max = P_teta[0][i]

for i in range(len(teta)):
  tetay[i] = teta[i]*(steps/math.pi)

#tetay.reverse()

for i in range(len(teta)):
  DN_NORM[i] = 20*math.log10(P_teta[0][i]/P_teta_max)

######################################################################################

plt.plot(tetay,DN_NORM,color='blue', linestyle='-', linewidth=2, label='Sphere Scatterplot')

#plt.xlim(-180, 180)
plt.xlim(np.min(tetay), np.max(tetay))
#plt.ylim(-40, 1)

# Показать сетку
plt.grid(True)

plt.show()

# Создайте поларный график
fig = plt.figure(figsize=(6, 6))  # Размеры фигуры
ax = fig.add_subplot(111, projection='polar')  # Создание полярной системы координат

# Постройте график на полярных координатах
ax.plot(teta, DN_NORM, color='blue', linestyle='-', linewidth=2, label='Sphere Scatterplot')

# Добавьте легенду
ax.legend(loc='upper right')

plt.title('Polar Scatterplot')
plt.show()

"""# Функция для расчета рассеяния на многослойном сферическом объекте

"""

import math
import cmath
import scipy.special
import numpy as np

def calculate_DN_NORM(k0, a, miy, eps):
    #Создаем массив для переменных среды
  n = len(eps)

  alfa = [0 * n for i in range(n)]
  beta = [0 * n for i in range(n)]
  etta = [0 * n for i in range(n)]

  k= [[0] * n for i in range(n)]

  #Расчет переменных, входящих в коэффициенты k
  for i in range(len(eps)):
    alfa[i] = math.atan((eps[i]).imag / (eps[i]).real)
    beta[i] = math.atan((miy[i]).imag / (miy[i]).real)
    etta[i] = math.sqrt(math.fabs(eps[i]) * math.fabs(miy[i]))

  #Расчет коэффициентов k
  j = 0; #Индекс для рассчета коэффициентов k
  for i in range (n):
    k[i][j] = k0 * a[i] * etta[j]
    if j < n - 1:
      j = j + 1
      k[i][j] = k0 * a[i] * etta[j]

  #scipy.special.jv(v, z, out=None)
  #Bessel function of the first kind of real order and complex argument.
  #Функция Бесселя первого рода д]
  J = [0 * n for i in range(toch)]

  for i in range(toch):
    nu = i + 1
    J[i] = (scipy.special.jv(nu + 0.5, k[0][0])) * (math.sqrt(k[0][0] * math.pi/2))

  #scipy.special.ivp
  #Compute derivatives of modified Bessel functions of the first kind.
  #Вычислить производные модифицированных функций Бесселя первого рода.
  Jpr = [0 * n for i in range(toch)]

  for i in range(toch):
    nu = i + 1
    Jpr[i] = ((nu / (2 * nu + 1)) *  (scipy.special.jv(nu - 0.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) -
        ((nu + 1) / (2 * nu + 1)) *  (scipy.special.jv(nu + 1.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) +
        (J[i] / k[0][0]))

  #scipy.special.yv(v, z, out=None)
  #Bessel function of the second kind of real order and complex argument.
  #Функция Бесселя второго рода (Функция Неймана) действительного порядка и комплексного аргумента.
  N = [0 * n for i in range(toch)]

  for i in range(toch):
    N[i] = scipy.special.yv((i+1) + 0.5, k[0][0]) * math.sqrt(k[0][0]* math.pi/2)

  Npr = [0 * n for i in range(toch)]
  for i in range(toch):
    nu = i + 1
    Npr[i] = ((nu / (2 * nu + 1)) *  (scipy.special.yv(nu - 0.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) -
        ((nu + 1) / (2 * nu + 1)) *  (scipy.special.yv(nu + 1.5, k[0][0]) * math.sqrt(k[0][0] * math.pi/2)) +
        (N[i] / k[0][0]))

  C = [[0] * (len(etta)-1) for i in range(toch)]
  for i in range(toch-1):
    for j in range(len(etta)-1):
      nu = i+1
      #C = J*Npr-N*Jpr
      C[i][j]=((scipy.special.jv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))*(((nu/(2*nu+1))*(((scipy.special.yv(nu-0.5,k[j][j+1]))*
      (math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1]-(((nu+1)/(2*nu+1))*((scipy.special.yv(nu+1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/
      k[j][j+1])* k[j][j+1]+((scipy.special.yv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])-((scipy.special.yv(nu+0.5,k[j+1][j+1]))*
      (math.sqrt(k[j+1][j+1]*math.pi/2)))*(((nu/(2*nu+1))*(((scipy.special.jv(nu-0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1]-
      (((nu+1)/(2*nu+1))*((scipy.special.jv(nu+1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])*k[j][j+1]+((scipy.special.jv(nu+0.5,k[j][j+1]))*
      (math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])

  #Производная C
  Cpr = [[0] * (len(etta)-1) for i in range(toch)]
  for i in range(toch):
    for j in range(len(etta)-1):
      nu = i+1
      #Cpr(n)=Jpr*Npr-Npr*Jpr
      Cpr[i][j] =(((( nu / (2 * nu + 1)) * (((scipy.special.jv(nu - 0.5, k[j+1][j+1])) * (math.sqrt(k[j+1][j+1] * math.pi/2))) / k[j+1][j+1])) *
                k[j+1][j+1]-(((nu +1)/(2*nu +1))*((scipy.special.jv(nu +1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2))) /
                k[j+1][j+1])*k[j+1][j+1]+((scipy.special.jv(nu +0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
                (((nu /(2*nu +1))*(((scipy.special.yv(nu -0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1] -
                (((nu +1)/(2*nu +1))*((scipy.special.yv(nu +1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])*k[j][j+1] +
                ((scipy.special.yv(nu +0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])) -((((nu /(2*nu +1)) *
                (((scipy.special.yv(nu -0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]))*k[j+1][j+1]-(((nu +1)/(2*nu +1)) *
                ((scipy.special.yv(nu +1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1])*k[j+1][j+1] +
                ((scipy.special.yv(nu +0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1])*(((nu /(2*nu +1)) *
                (((scipy.special.jv(nu -0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))*k[j][j+1]-(((nu +1)/(2*nu +1)) *
                ((scipy.special.jv(nu +1.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1])*k[j][j+1] +
                ((scipy.special.jv(nu +0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))/k[j][j+1]))

  S = [[0] * (len(etta)-1) for i in range(toch)]
  for i in range(toch):
    for j in range(len(etta)-1):
      nu = i+1
      S[i][j]=(((scipy.special.yv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))*((scipy.special.jv(nu+0.5,k[j][j+1])) *
              (math.sqrt(k[j][j+1]*math.pi/2))))-(((scipy.special.jv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2))) *
              ((scipy.special.yv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2))))

  #Производная S
  Spr = [[0] * (len(etta)-1) for i in range(toch)]
  for i in range(toch):
    for j in range(len(etta)-1):
      nu = i+1
      Spr[i][j]=((((nu/(2*nu+1))*(((scipy.special.yv(nu-0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1])) *
                k[j+1][j+1] -(((nu+1)/(2*nu+1))*(( scipy.special.yv(nu+1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2))) /
                k[j+1][j+1])*k[j+1][j+1] +((scipy.special.yv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
                ((scipy.special.jv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2)))) -((((nu/(2*nu+1)) *
                ((( scipy.special.jv(nu-0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]))*k[j+1][j+1] -
                (((nu+1)/(2*nu+1))*((scipy.special.jv(nu+1.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
                k[j+1][j+1] +((scipy.special.jv(nu+0.5,k[j+1][j+1]))*(math.sqrt(k[j+1][j+1]*math.pi/2)))/k[j+1][j+1]) *
                ((scipy.special.yv(nu+0.5,k[j][j+1]))*(math.sqrt(k[j][j+1]*math.pi/2))))

  alfa.append(0)
  eps.append(len(eps))
  Z = [[0] * (len(a)) for i in range(toch)]
  Y = [[0] * (len(a)) for i in range(toch)]
  for i in range(toch):
    for h in range(len(a)):

      if h==0:
        Z[i][h] = (cmath.sqrt((cmath.exp(alfa[1]*1j)*abs(eps[1]))/((cmath.exp(alfa[0]*1j)*abs(eps[0])))))*((Jpr[i])/(J[i]))
        Y[i][h] = (cmath.sqrt((cmath.exp(alfa[0]*1j)*abs(eps[0]))/((cmath.exp(alfa[1]*1j)*abs(eps[1])))))*((Jpr[i])/(J[i]))


  #### Этот блок надо починить. Не правильно считает для h=3, тут костыль ###############
      else:
        if h==3:
          Z[i][h]=(cmath.sqrt((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1]))/((cmath.exp(alfa[h]*1j)*abs(eps[h]))))) *(Cpr[i][h-1]+Z[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Z[i][h-1]*S[i][h-1])/2
          Y[i][h]=(cmath.sqrt((cmath.exp(alfa[h]*1j)*abs(eps[h]))/((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1])))))*(Cpr[i][h-1]+Y[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Y[i][h-1]*S[i][h-1])*2

  ######################################################################################

        else:
          Z[i][h]=(cmath.sqrt((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1]))/((cmath.exp(alfa[h]*1j)*abs(eps[h]))))) *(Cpr[i][h-1]+Z[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Z[i][h-1]*S[i][h-1])
          Y[i][h]=(cmath.sqrt((cmath.exp(alfa[h]*1j)*abs(eps[h]))/((cmath.exp(alfa[h+1]*1j)*abs(eps[h+1])))))*(Cpr[i][h-1]+Y[i][h-1]*Spr[i][h-1])/(C[i][h-1]+Y[i][h-1]*S[i][h-1])

  ######################################################################################
  mJ = [0 * n for i in range(toch)]
  mJpr = [0 * n for i in range(toch)]
  mH = [0 * n for i in range(toch)]
  mHpr = [0 * n for i in range(toch)]

  for i in range(toch):
    nu=i+1

    mJ[i] = (scipy.special.jv(nu+0.5,k0))*(math.sqrt(k0*math.pi/2))

    mJpr[i] = ((nu/(2*nu+1))*(((scipy.special.jv(nu-0.5,k0))*(math.sqrt(k0*math.pi/2)))/k0))*k0-(((nu+1)/(2*nu+1))*((scipy.special.jv(nu+1.5,k0))*(math.sqrt(k0*math.pi/2)))/k0)*k0+((scipy.special.jv(nu+0.5,k0))*(math.sqrt(k0*math.pi/2)))/k0;

    mH[i] = (scipy.special.hankel1(nu+0.5,k0))*(math.sqrt(k0*math.pi/2))

    mHpr[i] = ((nu/(2*nu+1))*(((scipy.special.hankel1(nu-0.5,k0))*(cmath.sqrt(k0*math.pi/2)))/k0))*k0 -(((nu+1)/(2*nu+1))*((scipy.special.hankel1(nu+1.5,k0))*(cmath.sqrt(k0*math.pi/2)))/k0)*k0+((scipy.special.hankel1(nu+0.5,k0))*(cmath.sqrt(k0*math.pi/2)))/k0

  ######################################################################################
  Mn = [0 * n for i in range(toch)]
  Nn = [0 * n for i in range(toch)]

  for i in range(toch):
    nu=i+1
    Mn[i]=(Z[i][h]*mJ[i]-mJpr[i])/(Z[i][h]*mH[i]-mHpr[i])
    Mn[i]=Mn[i].real-Mn[i].imag*1j
    Nn[i]=(Y[i][h]*mJ[i]-mJpr[i])/(Y[i][h]*mH[i]-mHpr[i])
    Nn[i]=Nn[i].real-Nn[i].imag*1j

  #teta=0.01:pi/180:2*pi; %диапазон изменения углов для декартовой системы координат

  i = [1, 2, 3]
  teta_start = 0.01
  teta_stop = 360
  teta_diap = abs(teta_stop)-abs(teta_start)
  step = math.pi/360
  steps = int(((teta_diap)*(math.pi/180)) / step)
  teta = [0 * n for i in range(steps)]
  cos_teta = [0 * n for i in range(steps)]
  print(step, steps, math.pi)
  for i in range(steps):
    if i == 0:
      teta[i] = (teta_start)*(math.pi/180)
    else:
      teta[i] = teta[i-1] + step
  print(teta)

  for i in range(steps):
    cos_teta[i] = math.cos(teta[i])

  M = [0 * n for i in range(steps)]
  Lm0=[0 * n for i in range(steps)]
  Lm1=[0 * n for i in range(steps)]
  Lm2=[0 * n for i in range(steps)]
  pii = [[0] * ((2*steps+1)) for i in range(toch+1)]
  tay = [[0] * ((2*steps+1)) for i in range(toch+1)]
  m=0

  for i in range(toch):
    m = m+1
    M = scipy.special.lpmv(0, m, cos_teta)
    Lm0 = M
    M = scipy.special.lpmv(1, m, cos_teta)
    Lm1 = M

    if m<2:
      Lm2 = 0
    else:
      M = scipy.special.lpmv(2, m, cos_teta)
      Lm2 = M

    for z in range(len(teta)):
      if (teta[z] > 0) & (teta[z] < math.pi):
        pii[i][z] = ((1)*Lm1[z])/(math.sin(teta[z]))
      else:
        if (teta[z] > math.pi) & (teta[z] < 2*math.pi):
          pii[i][z] = ((-1)*Lm1[z])/(math.sin(teta[z]))

    for z in range(len(teta)):
      if m<2:
        tay[i][z] = (1/2)*(-m*(m+1)*Lm0[z])
      else:
        tay[i][z] = (1/2)*(Lm2[z]-m*(m+1)*Lm0[z])

  ######################################################################################

  E_teta= [[0] * (len(teta)) for i in range(toch)]
  P_teta= [[0] * (len(teta)) for i in range(toch)]
  y=0

  for z in range(len(teta)):
    for p in range(toch):
      y=p+1
      E_teta[p][z]=((((2*y+1)/(y*(y+1)))*((-1)**y))*(tay[p][z]*Mn[p]-pii[p][z]*Nn[p]))

    for p in range(toch):
      y=p+1
      P_teta[0][z]=(P_teta[0][z]+E_teta[p][z])
    for p in range(toch):
      P_teta[0][z]=abs(P_teta[0][z])

  ######################################################################################

  tetay = [0 * n for i in range(steps)]
  DN_NORM = [0 * n for i in range(len(teta))]

  P_teta_max = 0

  for i in range(len(teta)):
    if P_teta[0][i] > P_teta_max:
      P_teta_max = P_teta[0][i]

  for i in range(len(teta)):
    tetay[i] = teta[i]*(steps/math.pi)

  #tetay.reverse()

  for i in range(len(teta)):
    DN_NORM[i] = 20*math.log10(P_teta[0][i]/P_teta_max)

    return DN_NORM, teta, tetay

# Заданные значения
k0 = 15 * math.pi
a = [0.34, 0.49, 0.59, 0.69, 0.77, 0.84, 0.91, 0.97]
miy = [1.94, 1.82, 1.71, 1.59, 1.47, 1.35, 1.24, 1.12]
eps = [1, 1, 1, 1, 1, 1, 1, 1]

DN_NORM, teta, tetay = calculate_DN_NORM(k0, a, miy, eps)

# Вывод значений
print("DN_NORM:", DN_NORM)

"""# Функция оформлена в виде класса"""

import math
import cmath
import scipy.special
import numpy as np

class DNCalculator:
    def calculate_DN_NORM(self, k0, a, miy, eps):
        n = len(eps)

        alfa = [math.atan((eps[i]).imag / (eps[i]).real) for i in range(n)]
        beta = [math.atan((miy[i]).imag / (miy[i]).real) for i in range(n)]
        etta = [math.sqrt(math.fabs(eps[i]) * math.fabs(miy[i])) for i in range(n)]

        k = [[0] * n for _ in range(n)]

        j = 0
        for i in range(n):
            k[i][j] = k0 * a[i] * etta[j]
            if j < n - 1:
                j = j + 1
                k[i][j] = k0 * a[i] * etta[j]

        M = 360
        step = math.pi / 180

        teta = np.arange(0.01 * math.pi / 180, 360 * math.pi / 180, step)
        cos_teta = np.cos(teta)

        Mn = [0] * M
        Nn = [0] * M

        for i in range(M):
            nu = i + 1
            Mn[i] = (scipy.special.jv(nu + 0.5, k0)) * (math.sqrt(k0 * math.pi / 2))
            Nn[i] = (scipy.special.yv(nu + 0.5, k0)) * (math.sqrt(k0 * math.pi / 2))

        teta_len = len(teta)
        steps = int(teta_len)
        M = [0] * steps
        Lm0 = [0] * steps
        Lm1 = [0] * steps
        Lm2 = [0] * steps
        pii = [[0] * (2 * steps + 1) for _ in range(n + 1)]
        tay = [[0] * (2 * steps + 1) for _ in range(n + 1)]

        for m in range(n):
            M = scipy.special.lpmv(0, m + 1, cos_teta)
            Lm0 = M
            M = scipy.special.lpmv(1, m + 1, cos_teta)
            Lm1 = M

            if m < 2:
                Lm2 = 0
            else:
                M = scipy.special.lpmv(2, m + 1, cos_teta)
                Lm2 = M

            for z in range(len(teta)):
                if (teta[z] > 0) and (teta[z] < math.pi):
                    pii[m][z] = ((1) * Lm1[z]) / (math.sin(teta[z]))
                else:
                    if (teta[z] > math.pi) and (teta[z] < 2 * math.pi):
                        pii[m][z] = ((-1) * Lm1[z]) / (math.sin(teta[z]))

            for z in range(len(teta)):
                if m < 2:
                    tay[m][z] = (1 / 2) * (-m * (m + 1) * Lm0[z])
                else:
                    tay[m][z] = (1 / 2) * (Lm2[z] - m * (m + 1) * Lm0[z])

        E_teta = [[0] * teta_len for _ in range(n)]
        P_teta = [0] * teta_len
        y = 0

        for z in range(len(teta)):
            for p in range(n):
                y = p + 1
                E_teta[p][z] = (((((2 * y + 1) / (y * (y + 1))) * ((-1) ** y)) *
                                (tay[p][z] * Mn[p] - pii[p][z] * Nn[p])))

            for p in range(n):
                y = p + 1
                P_teta[z] = (P_teta[z] + E_teta[p][z])

            P_teta[z] = abs(P_teta[z])

        P_teta_max = max(P_teta)

        tetay = teta * (steps / math.pi)
        DN_NORM = [20 * math.log10(P_teta[i] / P_teta_max) for i in range(teta_len)]

        return DN_NORM, teta, tetay

# Пример использования
dn_calculator = DNCalculator()

# Заданные значения
k0 = 15 * math.pi
a = [0.34, 0.49, 0.59, 0.69, 0.77, 0.84, 0.91, 0.97]
miy = [1.94, 1.82, 1.71, 1.59, 1.47, 1.35, 1.24, 1.12]
eps = [1, 1, 1, 1, 1, 1, 1, 1]

DN_NORM, teta, tetay = dn_calculator.calculate_DN_NORM(k0, a, miy, eps)

# Вывод значений
print("DN_NORM:", DN_NORM)

#вызов функции
# Создаем экземпляр класса DNCalculator
dn_calculator = DNCalculator()

# Заданные значения
k0 = 15 * math.pi
a = [0.34, 0.49, 0.59, 0.69, 0.77, 0.84, 0.91, 0.97]
miy = [1.94, 1.82, 1.71, 1.59, 1.47, 1.35, 1.24, 1.12]
eps = [1, 1, 1, 1, 1, 1, 1, 1]

# Вызываем метод calculate_DN_NORM для получения результатов
DN_NORM, teta, tetay = dn_calculator.calculate_DN_NORM(k0, a, miy, eps)

# Вывод результатов
print("DN_NORM class:", DN_NORM)